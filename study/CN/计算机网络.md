



# WEB页面请求过程

![image-20230201194009289](计算机网络.assets/image-20230201194009289.png)

## 1.HTTP

1. **浏览器做的第一步工作是解析 URL**

![image-20230201194231720](计算机网络.assets/image-20230201194231720.png)

![image-20230201194242046](计算机网络.assets/image-20230201194242046.png)

​	当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是 /index.html 或者 /default.html
​	这些文件，这样就不会发生混乱了

2. 生产HTTP请求报文

![image-20230201194939299](计算机网络.assets/image-20230201194939299.png)

![image-20230201194953305](计算机网络.assets/image-20230201194953305.png)

## 2. DNS

接下来需要委托操作系统把信息发向WEB服务器，这就需要找到WEB服务器域名对应的IP地址

<img src="计算机网络.assets/image-20230201195303296.png" alt="image-20230201195303296" style="zoom:67%;" />

**根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了**

![image-20230201195616612](计算机网络.assets/image-20230201195616612.png)

![image-20230201195632901](计算机网络.assets/image-20230201195632901.png)



## 3. 协议栈

通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈

![image-20230201200113599](计算机网络.assets/image-20230201200113599.png)





## 4. TCP

应用报文从套接字进入协议栈（HTTP基于TCP传输）

**TCP报文段格式**

<img src="计算机网络.assets/image-20230201200545934.png" alt="image-20230201200545934" style="zoom:67%;" />

<img src="计算机网络.assets/image-20230201200859346.png" alt="image-20230201200859346" style="zoom:67%;" />

Linux下的TCP连接

![image-20230201201920701](计算机网络.assets/image-20230201201920701.png)

HTTP请求报文不能超过MSS长度，如果超过，会进行分割

![image-20230201202448591](计算机网络.assets/image-20230201202448591.png)

![image-20230201202536116](计算机网络.assets/image-20230201202536116.png)

在握手成功之后，报文通过WEB服务器默认端口进入

## 5. IP

然后，TCP报文段需要通过协议栈中的IP模块将数据封装成网络包发送给通信对象

IP包头

![image-20230201203600151](计算机网络.assets/image-20230201203600151.png)

当存在多个网卡时，借助路由表来判断哪个网卡作为源地址IP，假设 Web 服务器的目标地址是 192.168.10.200

注意：源IP地址就是发送端网卡的IP地址，进行下图操作后，数据包从匹配条目的IFACE项（就是以太网网卡）发送

![image-20230201203934658](计算机网络.assets/image-20230201203934658.png)



## 6. MAC

生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部

MAC头部格式

![image-20230201205057492](计算机网络.assets/image-20230201205057492.png)

MAC 包头的协议类型只使用：0800 ： IP 协议     0806 ： ARP 协议
此时需要知道接收方的MAC地址，需要地址解析协议ARP！

<img src="计算机网络.assets/image-20230201205720728.png" alt="image-20230201205720728" style="zoom:67%;" />

存在ARP缓存

![image-20230201205841841](计算机网络.assets/image-20230201205841841.png)





# 网络安全

## 基本概念

密钥（KA）：数字或者字符，作为加密算法的输入

加密算法：用加密一方的密钥和明文报文（m)  作为输入

解密算法：用解密一方的密钥和密文报文（KA（m)  ）作为输入

报文摘要:（Message Digest）

散列报文鉴别码（Hashed MAC，HMAC) : 直接使用密码散列函数实现报文鉴别的技术, 不需要进行加密

数字签名（Digital Signature）：在计算机网络中传送的报文可以使用数字签名来证明其真实来源

实体鉴别：通信双方的一方验证另一方身份的技术，常简称为鉴别，实体可以是人、客户进程或服务器进程

不重数（nonce）：用来应对重放攻击，不重数可以使用户把重复的实体鉴别请求和新的实体鉴别请求区分开

密钥分配中心（Key Distribution Center，KDC）：其任务就是给需要进行秘密通信的用户临时分配一个会话密钥

![image-20230128201113780](计算机网络.assets/image-20230128201113780.png)

![image-20230128200743914](计算机网络.assets/image-20230128200743914.png)

## 对称密钥密码体制和公钥密码体制

### 公钥密码体制产生原因

![image-20230128201511165](计算机网络.assets/image-20230128201511165.png)

![image-20230128202513612](计算机网络.assets/image-20230128202513612.png)

注意：

PK只能用来加密，不能用来解密

公钥密码体制通常用于会话密钥的建立

## 报文摘要和报文鉴别码

为什么有报文摘要？因为总比加密这么长的报文效果要好

下图间的密钥只在双方间共享

加密后的报文摘要附在报文后面，称为报文鉴别码（MAC）

对于发送方产生的报文x和其相应的报文摘要H(x)，攻击者不可能伪造出另一个报文y，使得y与x具有同样的报文摘要

报文摘要算法：MD-5 ， SHA-1

![image-20230128202725979](计算机网络.assets/image-20230128202725979.png)

![image-20230128204407122](计算机网络.assets/image-20230128204407122.png)

<img src="计算机网络.assets/image-20230128204623824.png" alt="image-20230128204623824" style="zoom:67%;" />



## 数字签名

![image-20230131194441930](计算机网络.assets/image-20230131194441930.png)

![image-20230131195029731](计算机网络.assets/image-20230131195029731.png)

![image-20230131195252867](计算机网络.assets/image-20230131195252867.png)

**上面这种数字签名存在问题**

![image-20230131195346948](计算机网络.assets/image-20230131195346948.png)

**所以用下面这种保密性数字签名**

![image-20230131195403818](计算机网络.assets/image-20230131195403818.png)



## 实体鉴别

不重数可以使用户把重复的实体鉴别请求和新的实体鉴别请求区分开

![image-20230131200353103](计算机网络.assets/image-20230131200353103.png)

![image-20230131200751397](计算机网络.assets/image-20230131200751397.png)

![image-20230131201502729](计算机网络.assets/image-20230131201502729.png)

![image-20230131201846925](计算机网络.assets/image-20230131201846925.png)

所以需要CA



## 密钥分发

### 对称密钥的分发

![image-20230131202540009](计算机网络.assets/image-20230131202540009.png)

![image-20230131202719167](计算机网络.assets/image-20230131202719167.png)

### 公钥的分发

随意分发公钥的安全隐患

![image-20230131202941949](计算机网络.assets/image-20230131202941949.png)

因此，需要有一个值得信赖的机构将公钥与其对应的实体（人或机器）进行绑定（binding）。这种机构被称为认证中心（Certification Authority，CA），一般由政府出资建立

需要发布公钥的用户可以让CA**为其公钥**签发一个证书（Certification），**证书中包含有公钥及其拥有者的身份标识信息**（人名、公司名或IP地址等）

![image-20230131204212390](计算机网络.assets/image-20230131204212390.png)

![image-20230124211637780](计算机网络.assets/image-20230124211637780.png)

公钥基础结构（Public Key Infrastructure，PKI）

![image-20230131204614680](计算机网络.assets/image-20230131204614680.png)







## 攻击手段

![image-20230128200627819](计算机网络.assets/image-20230128200627819.png)

<img src="计算机网络.assets/image-20230128200648802.png" alt="image-20230128200648802" style="zoom: 67%;" />

![image-20230131195950301](计算机网络.assets/image-20230131195950301.png)





# 应用层

## HTTP(Hyper Text Transfer Protocol)

### 一些术语

**Web页面(文档）**

是由**对象**组成的。一个对象只是一个文件，诸如一个HTML 文件、一个JPEG 图形、一个Java 小程序或一个视频片段这样的文件，且它们可通过一个URL 地址寻址。

多数Web 页面含有一个HTML基本文件(base HTML file) 以及几个引用对象

HTML 基本文件通过对象的URL 地址引用页面中的其他对象

**URL的组成：**

* 存放对象的服务器主机名

* 对象的路径名

  比如 http: //www. someSchoo1. edu/ someDepartment/ picture.gif

  www. someSchoo1. edu是主机名，/someDepartment/ picture. gif 就是路径名



### HTTP的基本思想

当用户请求一个**Web 页面**（如点击一个超链接）时，浏览器向服务器发出对该页面中所包含对象的HTTP请求报文， 服务器接收到请求并用服务器的服务器包含这些对象的HTTP 响应报文进行响应

使用TCP为支撑协议，客户和服务器分别向其套接字接口发送和接受报文，一旦客户端向套接字发送了报文，报文就脱离了客户端的控制，转而由TCP控制

![image-20230127205259259](计算机网络.assets/image-20230127205259259.png)



HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据
的「约定和规范」。

基于TCP/IP，采用请求-应答的通信模式

文本：字符、图片、视频、压缩包等

超文本：文字、图片、视频等的混合体，超链接可以从一个超文本跳转到另一个超文本，HTML是最常见的超文本

* 进程与进程之间通信，具体来说，是客户的浏览器进程和WEB服务器进程间的通信，通过TCP连接，互相发送HTTP请求报文和HTTP响应报文

![image-20230123193408210](计算机网络.assets/image-20230123193408210.png)

* 建立在TCP连接（熟知端口号80）之上
* 两点之间传输的双向协议

### 不同版本的HTTP

* HTTP1.0

采用非持续连接方式，即浏览器每次请求一个文件，都要与服务器建立TCP连接，收到响应后立即关闭TCP连接

每请求一个文档就要有两倍的RTT的开销。若一个网页上有很多引用对象（例如图片等），那么请求每一个对象都需要花费2RTT的时间

![image-20230123195231627](计算机网络.assets/image-20230123195231627.png)

为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象。但是，这会大量占用万维网服务器的资源，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。

​	HTTP1.0 的连接方式

![image-20230128191332375](计算机网络.assets/image-20230128191332375.png)

* HTTP1.1

采用持续连接方式

报文的格式是**纯文本**形式的

万维网服务器在发送响应后仍然保持这条连接

HTTP/1.1的持续连接还可以使用流水线方式工作(浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文)

​	HTTP1.1的性能瓶颈

1. 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；
   发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
2. 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队
   头阻塞；
3. 没有请求优先级控制；
4. 请求只能从客户端开始，服务器只能被动响应。

* HTTP报文格式

HTTP是面向文本的，其报文中的每一个字段都是一些ASCII码串，并且每个字段的长度都是不确定的。

方法和字段：

Host字段（首部字段）：用来指定服务器的域名

Content-Length 字段：表明本次回应的数据长度

Connection 字段：要求服务器使用 TCP 持久连接，以便其他请求复用

User_agent字段：指明用户代理（浏览器）这样服务器就可以为不同的用户代理发送相同对象的不同版本

<img src="计算机网络.assets/image-20230124202849053.png" alt="image-20230124202849053" style="zoom:67%;" />

正因为HTTP1.1以长连接为基础，所以在一个TCP连接中，客户端可以同时发出多个请求，可以采用管道传输

<img src="计算机网络.assets/image-20230124203538980.png" alt="image-20230124203538980" style="zoom:67%;" />	`

![image-20230123205434968](计算机网络.assets/image-20230123205434968.png)

Content-Type 字段：用于服务器回应时，告诉客户端，本次数据是什么格式

![image-20230123205602605](计算机网络.assets/image-20230123205602605.png)

![image-20230123200801071](计算机网络.assets/image-20230123200801071.png)



![image-20230123201001683](计算机网络.assets/image-20230123201001683.png)

![image-20230123204626034](计算机网络.assets/image-20230123204626034.png)

![image-20230123200511032](计算机网络.assets/image-20230123200511032.png)

### Get和Post有什么区别？

Get：请求从服务器**获取**资源

<img src="计算机网络.assets/image-20230123210047186.png" alt="image-20230123210047186" style="zoom: 67%;" />

Post：向 URI 指定的资源**提交**数据，数据就放在报文的 body 里。

<img src="计算机网络.assets/image-20230124201741388.png" alt="image-20230124201741388" style="zoom:67%;" />

* Get方法实体体为空，而Post方法实体体不为空
* HTTP响应报文的实体体中存放着请求的文档数据
* HTTP响应报文的Last_Modified首部行对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要

### GET 和 POST 方法都是安全和幂等的吗？

安全: 请求方法不会「破坏」服务器上的资源

幂等: 多次执行相同的操作，结果都是「相同」的

GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。
POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。

### HTTP的缺点

1. 无状态。解决方法：cookie
2. 明文传输，容易被窃取
3. 不安全 解决方法：TLS/SSL

### HTTP/1.1 相比 HTTP/1.0 提高了什么性能？

1. 使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
2. 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求
   出去，可以减少整体的响应时间

### HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？

HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

HTTP/2 相比 HTTP/1.1 性能上的改进：

1. 头部压缩

   如果多个请求头部一样或相似，就回消除重复部分——HPACK算法，：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

2. 二进制

   格式头信息和数据体都是二进制（而不是HTTP1.1的文本），并且统称为帧（frame）：头信息帧和数据帧。增加传输效率

<img src="计算机网络.assets/image-20230125214027372.png" alt="image-20230125214027372" style="zoom: 50%;" />

3. 数据流

   数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必
   须要对数据包做标记，指出它属于哪个回应。**每个请求或回应的所有数据包**，称为一个数据流（ Stream ）, 客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数

4. 优先级

   客户端还可以指定**数据流的**优先级。优先级高的请求，服务器就先响应该请求。

<img src="计算机网络.assets/image-20230125215103568.png" alt="image-20230125215103568" style="zoom:50%;" />

5. 多路复用

   HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。
   移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。

   <img src="计算机网络.assets/image-20230125215411710.png" alt="image-20230125215411710" style="zoom:50%;" />

6. 服务器推送

   HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动
   向客户端发送消息。
   举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给
   客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。

### HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？

HTTP/2 主要的问题在于，**多个 HTTP 请求在复用一个 TCP 连接**，下层的 TCP 协议是不知道有多少个
HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有
的 HTTP 请求都必须等待这个丢了的包被重传回来。

* HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞，那么队列后请求也统统被阻塞住了
* HTTP/2 多个请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。

所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！

基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。

头部压缩算法升级成了QPack

HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。

<img src="计算机网络.assets/image-20230125220111796.png" alt="image-20230125220111796" style="zoom:67%;" />

<img src="计算机网络.assets/image-20230125220348330.png" alt="image-20230125220348330" style="zoom:80%;" />

## HTTPS

HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式

### HTTP与HTTPS有什么区别

1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全
的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP
三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
3. HTTP 的端口号是 80，HTTPS 的端口号是 443。
4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

<img src="计算机网络.assets/image-20230124204144362.png" alt="image-20230124204144362" style="zoom:50%;" />

### HTTPS的解决方案

* HTTP的**窃听**危机——**机密性**——HTTPS解决：采用**混合加密**

**混合加密**：保证信息的机密性，解决了窃听的风险

在通信建立**前**采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
在通信过程**中**全部使用**对称加密**的「会话秘钥」的方式加密明文数据。

**为什么采用混合加密？**

对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但
速度慢。

<img src="计算机网络.assets/image-20230124205448727.png" alt="image-20230124205448727" style="zoom:67%;" />

* HTTP的**篡改**风险——**完整性**——HTTPS解决：采用**摘要算法**

**摘要算法**：用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。

![image-20230124210706971](计算机网络.assets/image-20230124210706971.png)

* HTTP**的冒充风险**——**实体鉴别**——HTTPS解决：将服务器**公钥放入数字证书**中

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密

有一个问题：如何保证公钥不被篡改和信任度？——解决方法：CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

![image-20230124211637780](计算机网络.assets/image-20230124211637780.png)

### HTTPS的连接过程

1. 客户端向服务器索要并验证服务器的公钥。
2. 双方协商生产「会话秘钥」。
3. 双方采用「会话秘钥」进行加密通信。

前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。

**SSL/TLS四握手**

见小林图解网络P19

[点击这里](F:\Caoyan\program\cpp\计算机网络\亮白风格-图解网络-小林coding-v2.0.pdf)

## Cookie

背景：HTTP是无状态协议，需要Cookie来保留状态，需要万维网服务器能够识别用户，对无状态的HTTP进行状态化的技术

**Cookie的组件**

1. 在HTTP 响应报文中的一个cookie **首部行**； 
2. 在HTTP 请求报文中的一个cookie **首部行**； 

3. 在用户端系统中保留有一个cookie 文件，并由用户的浏览器进行管理； 

4. 位于Web 站点的一个后端数据库

工作流程

3. 这个HTTP响应报文包含有一个首部字段“Set-Cookie"的首部行

![image-20230123202036179](计算机网络.assets/image-20230123202036179.png)

![image-20230128195215429](计算机网络.assets/image-20230128195215429.png)



# 运输层



# 网络层



# 数据链路层



# 物理层







