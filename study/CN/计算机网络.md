

# 应用层

## HTTP(Hyper Text Transfer Protocol)

### 一些术语

**Web页面(文档）**

是由**对象**组成的。一个对象只是一个文件，诸如一个HTML 文件、一个JPEG 图形、一个Java 小程序或一个视频片段这样的文件，且它们可通过一个URL 地址寻址。

多数Web 页面含有一个HTML基本文件(base HTML file) 以及几个引用对象

HTML 基本文件通过对象的URL 地址引用页面中的其他对象

**URL的组成：**

* 存放对象的服务器主机名

* 对象的路径名

  比如 http: //www. someSchoo1. edu/ someDepartment/ picture.gif

  www. someSchoo1. edu是主机名，/someDepartment/ picture. gif 就是路径名



### HTTP的基本思想

当用户请求一个**Web 页面**（如点击一个超链接）时，浏览器向服务器发出对该页面中所包含对象的HTTP请求报文， 服务器接收到请求并用服务器的服务器包含这些对象的HTTP 响应报文进行响应

使用TCP为支撑协议，客户和服务器分别向其套接字接口发送和接受报文，一旦客户端向套接字发送了报文，报文就脱离了客户端的控制，转而由TCP控制

![image-20230127205259259](计算机网络.assets/image-20230127205259259.png)





















HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据
的「约定和规范」。

基于TCP/IP，采用请求-应答的通信模式

文本：字符、图片、视频、压缩包等

超文本：文字、图片、视频等的混合体，超链接可以从一个超文本跳转到另一个超文本，HTML是最常见的超文本

* 进程与进程之间通信，具体来说，是客户的浏览器进程和WEB服务器进程间的通信，通过TCP连接，互相发送HTTP请求报文和HTTP响应报文

![image-20230123193408210](计算机网络.assets/image-20230123193408210.png)

* 建立在TCP连接（熟知端口号80）之上
* 两点之间传输的双向协议

### 不同版本的HTTP

* HTTP1.0

采用非持续连接方式，即浏览器每次请求一个文件，都要与服务器建立TCP连接，收到响应后立即关闭TCP连接

每请求一个文档就要有两倍的RTT的开销。若一个网页上有很多引用对象（例如图片等），那么请求每一个对象都需要花费2RTT的时间

![image-20230123195231627](计算机网络.assets/image-20230123195231627.png)

为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象。但是，这会大量占用万维网服务器的资源，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。

* HTTP1.1

采用持续连接方式

报文的格式是**纯文本**形式的

万维网服务器在发送响应后仍然保持这条连接

HTTP/1.1的持续连接还可以使用流水线方式工作(浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文)

​	HTTP1.1的性能瓶颈

1. 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；
   发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
2. 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队
   头阻塞；
3. 没有请求优先级控制；
4. 请求只能从客户端开始，服务器只能被动响应。

* HTTP报文格式

HTTP是面向文本的，其报文中的每一个字段都是一些ASCII码串，并且每个字段的长度都是不确定的。

方法和字段：

Host字段（首部字段）：用来指定服务器的域名、

Content-Length 字段：表明本次回应的数据长度

Connection 字段：要求服务器使用 TCP 持久连接，以便其他请求复用

<img src="计算机网络.assets/image-20230124202849053.png" alt="image-20230124202849053" style="zoom:67%;" />

正因为HTTP1.1以长连接为基础，所以在一个TCP连接中，客户端可以同时发出多个请求，可以采用管道传输

<img src="计算机网络.assets/image-20230124203538980.png" alt="image-20230124203538980" style="zoom:67%;" />	`

![image-20230123205434968](计算机网络.assets/image-20230123205434968.png)

Content-Type 字段：用于服务器回应时，告诉客户端，本次数据是什么格式

![image-20230123205602605](计算机网络.assets/image-20230123205602605.png)



![image-20230123200801071](计算机网络.assets/image-20230123200801071.png)

![image-20230123201001683](计算机网络.assets/image-20230123201001683.png)

![image-20230123204626034](计算机网络.assets/image-20230123204626034.png)

![image-20230123200511032](计算机网络.assets/image-20230123200511032.png)

### Get和Post有什么区别？

Get：请求从服务器**获取**资源

<img src="计算机网络.assets/image-20230123210047186.png" alt="image-20230123210047186" style="zoom: 67%;" />

Post：向 URI 指定的资源**提交**数据，数据就放在报文的 body 里。

<img src="计算机网络.assets/image-20230124201741388.png" alt="image-20230124201741388" style="zoom:67%;" />

### GET 和 POST 方法都是安全和幂等的吗？

安全: 请求方法不会「破坏」服务器上的资源

幂等: 多次执行相同的操作，结果都是「相同」的

GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。
POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。

### HTTP的缺点

1. 无状态。解决方法：cookie
2. 明文传输，容易被窃取
3. 不安全 解决方法：TLS/SSL

### HTTP/1.1 相比 HTTP/1.0 提高了什么性能？

1. 使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
2. 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求
   出去，可以减少整体的响应时间

### HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？

HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

HTTP/2 相比 HTTP/1.1 性能上的改进：

1. 头部压缩

   如果多个请求头部一样或相似，就回消除重复部分——HPACK算法，：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

2. 二进制

   格式头信息和数据体都是二进制（而不是HTTP1.1的文本），并且统称为帧（frame）：头信息帧和数据帧。增加传输效率

<img src="计算机网络.assets/image-20230125214027372.png" alt="image-20230125214027372" style="zoom: 50%;" />

3. 数据流

   数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必
   须要对数据包做标记，指出它属于哪个回应。**每个请求或回应的所有数据包**，称为一个数据流（ Stream ）, 客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数

4. 优先级

   客户端还可以指定**数据流的**优先级。优先级高的请求，服务器就先响应该请求。

<img src="计算机网络.assets/image-20230125215103568.png" alt="image-20230125215103568" style="zoom:50%;" />

5. 多路复用

   HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。
   移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。

   <img src="计算机网络.assets/image-20230125215411710.png" alt="image-20230125215411710" style="zoom:50%;" />

6. 服务器推送

   HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动
   向客户端发送消息。
   举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给
   客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。

### HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？

HTTP/2 主要的问题在于，**多个 HTTP 请求在复用一个 TCP 连接**，下层的 TCP 协议是不知道有多少个
HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有
的 HTTP 请求都必须等待这个丢了的包被重传回来。

* HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞，那么队列后请求也统统被阻塞住了
* HTTP/2 多个请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。

所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！

基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。

头部压缩算法升级成了QPack

HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。

<img src="计算机网络.assets/image-20230125220111796.png" alt="image-20230125220111796" style="zoom:67%;" />

<img src="计算机网络.assets/image-20230125220348330.png" alt="image-20230125220348330" style="zoom:80%;" />

## HTTPS

HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式

### HTTP与HTTPS有什么区别

1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全
的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP
三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
3. HTTP 的端口号是 80，HTTPS 的端口号是 443。
4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

<img src="计算机网络.assets/image-20230124204144362.png" alt="image-20230124204144362" style="zoom:50%;" />

### HTTPS的解决方案

* HTTP的**窃听**危机——**机密性**——HTTPS解决：采用**混合加密**

**混合加密**：保证信息的机密性，解决了窃听的风险

在通信建立**前**采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
在通信过程**中**全部使用**对称加密**的「会话秘钥」的方式加密明文数据。

**为什么采用混合加密？**

对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但
速度慢。

<img src="计算机网络.assets/image-20230124205448727.png" alt="image-20230124205448727" style="zoom:67%;" />

* HTTP的**篡改**风险——**完整性**——HTTPS解决：采用**摘要算法**

**摘要算法**：用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。

![image-20230124210706971](计算机网络.assets/image-20230124210706971.png)

* HTTP**的冒充风险**——**实体鉴别**——HTTPS解决：将服务器**公钥放入数字证书**中

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密

有一个问题：如何保证公钥不被篡改和信任度？——解决方法：CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

![image-20230124211637780](计算机网络.assets/image-20230124211637780.png)

### HTTPS的连接过程

1. 客户端向服务器索要并验证服务器的公钥。
2. 双方协商生产「会话秘钥」。
3. 双方采用「会话秘钥」进行加密通信。

前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。

**SSL/TLS四握手**

见小林图解网络P19

[点击这里](F:\Caoyan\program\cpp\计算机网络\亮白风格-图解网络-小林coding-v2.0.pdf)

## Cookie

背景：HTTP是无状态协议，需要Cookie来保留状态，需要万维网服务器能够识别用户，对无状态的HTTP进行状态化的技术

工作流程

3. 这个HTTP响应报文包含有一个首部字段“Set-Cookie"的首部行

![image-20230123202036179](计算机网络.assets/image-20230123202036179.png)





# 运输层



# 网络层



# 数据链路层



# 物理层





